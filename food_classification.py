# -*- coding: utf-8 -*-
"""Food_classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VioLPv7bTNcFeHHuqSByRLIfDEg-QEJD
"""

import os
from PIL import Image

# Paths
input_dir = r"/content/drive/MyDrive/Food Images - Copy"              # your original folder
output_dir = "/content/drive/MyDrive/ResizedFood Images - Copy"     # folder to save resized images
target_size = (224, 224)

# Create output folder if not exist
os.makedirs(output_dir, exist_ok=True)

# Loop through each food class folder
for category in os.listdir(input_dir):
    class_path = os.path.join(input_dir, category)
    save_class_path = os.path.join(output_dir, category)

    if not os.path.isdir(class_path):
        continue

    os.makedirs(save_class_path, exist_ok=True)

    # Resize each image
    for img_name in os.listdir(class_path):
        img_path = os.path.join(class_path, img_name)

        try:
            img = Image.open(img_path).convert("RGB")
            img = img.resize(target_size)
            img.save(os.path.join(save_class_path, img_name))
        except Exception as e:
            print(f"Failed to process {img_path}: {e}")

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import MobileNetV2
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam
import os

# ‚úÖ Path to your resized image folder
DATA_DIR = r"/content/drive/MyDrive/ResizedFood Images - Copy"

# üîß Parameters
IMG_SIZE = 224
BATCH_SIZE = 16
EPOCHS = 10

# üîÅ Data Augmentation & Preprocessing
datagen = ImageDataGenerator(
    rescale=1./255,
    validation_split=0.2,
    rotation_range=20,
    zoom_range=0.2,
    horizontal_flip=True
)

train_gen = datagen.flow_from_directory(
    DATA_DIR,
    target_size=(IMG_SIZE, IMG_SIZE),
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    subset='training'
)

val_gen = datagen.flow_from_directory(
    DATA_DIR,
    target_size=(IMG_SIZE, IMG_SIZE),
    batch_size=BATCH_SIZE,
    class_mode='categorical',
    subset='validation'
)

# ‚úÖ Load Pretrained MobileNetV2
base_model = MobileNetV2(weights='imagenet', include_top=False, input_shape=(IMG_SIZE, IMG_SIZE, 3))
base_model.trainable = False  # Freeze base

# üì¶ Add classification head
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(128, activation='relu')(x)
output = Dense(train_gen.num_classes, activation='softmax')(x)

model = Model(inputs=base_model.input, outputs=output)

# üß™ Compile
model.compile(optimizer=Adam(learning_rate=0.0001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# üèãÔ∏è Train
model.fit(train_gen, validation_data=val_gen, epochs=EPOCHS)

# üíæ Save model
model.save("food_classifier_mobilenet.h5")
print("‚úÖ Model saved as 'food_classifier_mobilenet.h5'")

from tensorflow.keras.models import load_model

# Load the saved model
model = load_model('food_classifier_mobilenet.h5')

from tensorflow.keras.preprocessing import image
import numpy as np
import os

IMG_SIZE = 224  # Should match your model input size

def predict_food(img_path, model, class_labels):
    img = image.load_img(img_path, target_size=(IMG_SIZE, IMG_SIZE))
    img_array = image.img_to_array(img) / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    predictions = model.predict(img_array)
    predicted_class = class_labels[np.argmax(predictions)]

    return predicted_class

class_labels = list(train_gen.class_indices.keys())

class_labels

import pandas as pd

# Load the CSV with nutrition info
df_nutrition = pd.read_csv('sample_food_nutrition.csv')

# Check what's inside
print(df_nutrition)

def get_nutrition_info(food_label, nutrition_df):
    # Match the predicted food name with food_name column
    row = nutrition_df[nutrition_df['food_name'].str.lower() == food_label.lower()]

    if not row.empty:
        row = row.iloc[0]
        return {
            "Calories": row['calories'],
            "Protein": row['protein'],
            "Fat": row['fat'],
            "Carbs": row['carbs']
        }
    else:
        return {
            "Calories": "N/A",
            "Protein": "N/A",
            "Fat": "N/A",
            "Carbs": "N/A"
        }

image_path = "/content/OIP (1).jpeg"
predicted_food = predict_food(image_path, model, class_labels)
nutrition_info = get_nutrition_info(predicted_food, df_nutrition)

print(f"üçΩÔ∏è Predicted Food: {predicted_food}")
print(f"üî• Calories: {nutrition_info['Calories']}")
print(f"üí™ Protein: {nutrition_info['Protein']}")
print(f"ü•ë Fat: {nutrition_info['Fat']}")
print(f"üçû Carbs: {nutrition_info['Carbs']}")

# After predicting the food image
predicted_food = predict_food(image_path, model, class_labels)

# Get nutritional values
nutrition_info = get_nutrition_info(predicted_food, df_nutrition)

print(f"üçΩÔ∏è Predicted Food: {predicted_food}")
print(f"üî• Calories: {nutrition_info['Calories']}")
print(f"üí™ Protein: {nutrition_info['Protein']}g")
print(f"ü•ë Fat: {nutrition_info['Fat']}g")
print(f"üçû Carbs: {nutrition_info['Carbs']}g")

!pip install streamlit pyngrok --quiet

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import numpy as np
# from PIL import Image
# import tensorflow as tf
# import pandas as pd
# 
# # Load model
# model = tf.keras.models.load_model("food_classifier_mobilenet.h5")
# 
# # Class labels
# class_labels = ['biryani', 'burger', 'dosa', 'fries', 'idli', 'pasta', 'pizza', 'salad', 'sandwich', 'upma']
# 
# # Load nutrition dataset
# nutrition_df = pd.read_csv("sample_food_nutrition.csv")
# 
# # Resize and preprocess uploaded image
# def preprocess_image(image):
#     image = image.resize((224, 224))
#     img_array = tf.keras.utils.img_to_array(image)
#     img_array = np.expand_dims(img_array, axis=0)
#     return tf.keras.applications.mobilenet_v2.preprocess_input(img_array)
# 
# # Predict food class
# def predict_food(image, model):
#     processed_img = preprocess_image(image)
#     prediction = model.predict(processed_img)
#     predicted_class = class_labels[np.argmax(prediction)]
#     return predicted_class
# 
# # Get nutrition info from CSV
# def get_nutrition_info(food_label, nutrition_df):
#     row = nutrition_df[nutrition_df['food_name'].str.lower() == food_label.lower()]
#     if not row.empty:
#         row = row.iloc[0]
#         return {
#             "Calories": row['calories'],
#             "Protein": row['protein'],
#             "Fat": row['fat'],
#             "Carbs": row['carbs']
#         }
#     else:
#         return {
#             "Calories": "N/A",
#             "Protein": "N/A",
#             "Fat": "N/A",
#             "Carbs": "N/A"
#         }
# 
# # Streamlit App
# st.title("üçî Food Recognition & Nutrition Estimator")
# st.markdown("Upload a food image and get its estimated nutritional values.")
# 
# uploaded_file = st.file_uploader("üì∑ Upload Food Image", type=["jpg", "jpeg", "png"])
# 
# if uploaded_file is not None:
#     image = Image.open(uploaded_file)
#     st.image(image, caption="Uploaded Image", use_column_width=True)
# 
#     with st.spinner("Analyzing..."):
#         food_name = predict_food(image, model)
#         nutrition = get_nutrition_info(food_name, nutrition_df)
# 
#     st.success(f"üçΩÔ∏è Predicted Food: **{food_name.title()}**")
# 
#     st.subheader("üî¨ Estimated Nutrition:")
#     st.write(f"üî• **Calories:** {nutrition['Calories']} kcal")
#     st.write(f"üí™ **Protein:** {nutrition['Protein']} g")
#     st.write(f"ü•ë **Fat:** {nutrition['Fat']} g")
#     st.write(f"üçû **Carbs:** {nutrition['Carbs']} g")
#

